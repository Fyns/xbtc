#include "MerkleTree.hpp"

#include "Block.hpp"
#include "Transaction.hpp"
#include "util/Hasher.hpp"
#include <xul/log/log.hpp>
#include <xul/data/big_number_io.hpp>

namespace xbtc {


uint256 MerkleTree::build(const Block* block, bool* mutated)
{
    XUL_APP_DEBUG("MerkleTree::build " << block->transactions.size());
    std::vector<uint256> leaves;
    leaves.resize(block->transactions.size());
    for (int i = 0; i < block->transactions.size(); ++i) {
        leaves[i] = block->transactions[i].getHash();
        XUL_APP_DEBUG("MerkleTree::build leave " << i << " " << leaves[i]);
    }
    return computeRoot(leaves, mutated);
}

uint256 MerkleTree::hashSiblingLeaves(const uint256& x, const uint256& y)
{
    Hasher256 hasher;
    hasher.update(x.data(), 32);
    hasher.update(y.data(), 32);
    return hasher.finalize();
}

/* This implements a constant-space merkle root/path calculator, limited to 2^32 leaves. */
void MerkleTree::compute(const std::vector<uint256>& leaves, uint256* proot, bool* pmutated, uint32_t branchpos, std::vector<uint256>* pbranch) {
    if (pbranch) pbranch->clear();
    if (leaves.size() == 0) {
        if (pmutated) *pmutated = false;
        if (proot) *proot = uint256();
        return;
    }
    bool mutated = false;
    // count is the number of leaves processed so far.
    uint32_t count = 0;
    // inner is an array of eagerly computed subtree hashes, indexed by tree
    // level (0 being the leaves).
    // For example, when count is 25 (11001 in binary), inner[4] is the hash of
    // the first 16 leaves, inner[3] of the next 8 leaves, and inner[0] equal to
    // the last leaf. The other inner entries are undefined.
    uint256 inner[32];
    // Which position in inner is a hash that depends on the matching leaf.
    int matchlevel = -1;
    // First process all leaves into 'inner' values.
    while (count < leaves.size()) {
        uint256 h = leaves[count];
        bool matchh = count == branchpos;
        count++;
        int level;
        // For each of the lower bits in count that are 0, do 1 step. Each
        // corresponds to an inner value that existed before processing the
        // current leaf, and each needs a hash to combine it.
        for (level = 0; !(count & (((uint32_t)1) << level)); level++) {
            if (pbranch) {
                if (matchh) {
                    pbranch->push_back(inner[level]);
                } else if (matchlevel == level) {
                    pbranch->push_back(h);
                    matchh = true;
                }
            }
            mutated |= (inner[level] == h);
            h = hashSiblingLeaves(inner[level], h);
//            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());
        }
        // Store the resulting hash at inner position level.
        inner[level] = h;
        if (matchh) {
            matchlevel = level;
        }
    }
    // Do a final 'sweep' over the rightmost branch of the tree to process
    // odd levels, and reduce everything to a single top value.
    // Level is the level (counted from the bottom) up to which we've sweeped.
    int level = 0;
    // As long as bit number level in count is zero, skip it. It means there
    // is nothing left at this level.
    while (!(count & (((uint32_t)1) << level))) {
        level++;
    }
    uint256 h = inner[level];
    bool matchh = matchlevel == level;
    while (count != (((uint32_t)1) << level)) {
        // If we reach this point, h is an inner value that is not the top.
        // We combine it with itself (Bitcoin's special rule for odd levels in
        // the tree) to produce a higher level one.
        if (pbranch && matchh) {
            pbranch->push_back(h);
        }
        h = hashSiblingLeaves(h, h);
//        CHash256().Write(h.begin(), 32).Write(h.begin(), 32).Finalize(h.begin());
        // Increment count to the value it would have if two entries at this
        // level had existed.
        count += (((uint32_t)1) << level);
        level++;
        // And propagate the result upwards accordingly.
        while (!(count & (((uint32_t)1) << level))) {
            if (pbranch) {
                if (matchh) {
                    pbranch->push_back(inner[level]);
                } else if (matchlevel == level) {
                    pbranch->push_back(h);
                    matchh = true;
                }
            }
            h = hashSiblingLeaves(inner[level], h);
//            CHash256().Write(inner[level].begin(), 32).Write(h.begin(), 32).Finalize(h.begin());
            level++;
        }
    }
    // Return result.
    if (pmutated) *pmutated = mutated;
    if (proot) *proot = h;
}

uint256 MerkleTree::computeRoot(const std::vector<uint256>& leaves, bool* mutated) {
    uint256 hash;
    compute(leaves, &hash, mutated, -1, nullptr);
    return hash;
}


}
